# 코딩테스트 효율적으로 준비하기

## 목차
- [문제 분석](#문제-분석)
- [의사 코드 작성](#의사-코드-작성)
- [자바 성능 최적화](#자바-성능-최적화)
  - [프리미티브 vs 레퍼런스 타입](#프리미티브-vs-레퍼런스-타입)
  - [String vs StringBuilder](#string-vs-stringbuilder)

---

## 문제 분석

> 전체 시간의 50~60%는 문제 분석에 시간을 쓰는 것 추천

### 분석 단계

1. **문제를 쪼개서 동작 단위로 분석**
2. **제약 사항을 파악하고 테스트 케이스를 추가**
3. **알고리즘 시간 복잡도를 파악하여 입력값 분석**
4. **그리디하게 접근할 때 논리적 오류 없도록, 근거 명확히**
5. **데이터 흐름이나 구성 파악**
   - 데이터 값 차이 크면 데이터 값 자체를 배열의 인덱스로 활용 피하는 것이 좋음

---

## 의사 코드 작성

> 의사 코드: 프로그램의 논리를 설명하고 알고리즘을 표현하기 위해 작성하는 지침

### 작성 원칙

1. 문제 **해결 순서**대로 **동작 중심**으로 작성
2. 충분히 테스트하기

---

## 자바 성능 최적화

### 프리미티브 vs 레퍼런스 타입

자바 데이터 타입에는 프리미티브 타입과 레퍼런스 타입이 있음  
→ 프리미티브 타입의 연산 속도가 레퍼런스 타입에 비해 빠름

#### 속도 차이 이유: 메모리 구조 차이

**프리미티브 타입 (빠름 ⚡)**
```
Stack 메모리
┌─────────┐
│ a = 10  │  ← 값 직접 저장
└─────────┘
```

**레퍼런스 타입 (느림 🐢)**
```
Stack 메모리          Heap 메모리
┌─────────┐          ┌─────────┐
│ a = 주소 │ ------→ │   10    │
└─────────┘          └─────────┘
    참조               실제 값
```

→ 레퍼런스는 "주소 찾아가기" 한 단계 더 필요!

#### 타입 비교

**프리미티브 타입 (Primitive)**
- int, long, double, boolean, char 등
- 값을 직접 저장 → **연산 속도 빠름** ⚡
- null 사용 불가
- **코테에서는 우선 사용!**

**레퍼런스 타입 (Reference)**
- Integer, Long, Double, String, ArrayList 등
- 주소를 저장 → 값은 Heap에 저장
- null 사용 가능
- 컬렉션에 필요 (ArrayList<Integer>)

#### 코테 실전 전략

- 일반 변수/배열 → **프리미티브** (int, int[])
- 컬렉션 → 어쩔 수 없이 래퍼 (ArrayList<Integer>)
- 불필요한 오토박싱 피하기!

#### 박싱/언박싱 주의

**박싱과 언박싱을 많이 하면 성능 저하**

```java
// ❌ 느린 코드 (박싱/언박싱 반복)
Integer sum = 0;
for(int i = 0; i < 1000000; i++) {
    sum += i;  // 언박싱 → 연산 → 박싱 (100만 번!)
}

// ✅ 빠른 코드
int sum = 0;
for(int i = 0; i < 1000000; i++) {
    sum += i;  // 직접 연산
}
```

---

### String vs StringBuilder

#### String의 특징

문자열 = 문자들을 배열 형태로 구성한 **변경할 수 없는 객체 (Immutable 객체)**

- 값 변경 불가 → + 연산 등 값 변경 시 시간 복잡도 관점에서 사용 주의
- 문자열 추가, 삭제 → 수정하는 것이 아닌 **새로운 객체 반환**

```java
// ❌ 매우 느림 (매번 새 객체 생성)
String result = "";
for(int i = 0; i < 1000; i++) {
    result += i;  // 1000번의 객체 생성!
}

// ✅ 빠름
StringBuilder sb = new StringBuilder();
for(int i = 0; i < 1000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

#### StringBuilder vs StringBuffer

둘 다 **Mutable**하므로 값을 변경할 때 시간 복잡도 관점에서 효율적  
차이는 멀티스레드 환경에서 **Thread-Safe** 여부

| 클래스 | Thread-Safe? | 속도 | 언제 사용? |
|--------|--------------|------|-----------|
| **StringBuilder** | ❌ 없음 | 빠름 ⚡ | **단일 스레드** (코테) |
| **StringBuffer** | ✅ 있음 | 느림 🐢 | **멀티 스레드** (실무) |

**Thread-Safe란?**
- 여러 스레드가 동시에 접근해도 안전

**코테 결론**
- Thread-Safe가 없는 StringBuilder 클래스가 속도면에서 빠름
- → **코테 때는 StringBuilder 사용하면 됨**

---

## 시간 복잡도 기준

| N 크기 | 적합한 시간 복잡도 |
|--------|-------------------|
| N ≤ 100 | O(N³) |
| N ≤ 1,000 | O(N²) |
| N ≤ 10,000 | O(N log N) |
| N ≤ 100,000 | O(N) |
| N ≤ 1,000,000 | O(N) 또는 O(log N) |
